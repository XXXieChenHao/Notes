<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <button id="btn">点击</button>
  <script type="text/javascript">
    // function test() {
    //   this.a = 1; // window.a --> 1
    //   console.log(this);  // window
    //   console.log(this.a)
    // }

    // test()
    // var a = 1;
    // function test() {
    //   'use strict'
    //   // 严格模式 普通函数中 this 为 undefined
    //   console.log(this);
    //   console.log(this.a)
    // }
    // test()

    // 对象中的属性在方法内部可以通过 this 先访问到对象本身 通过 . 访问到属性
    // var a = 2;
    // var obj = {
    //   a: 1,
    //   test: function () {
    //     console.log(this);   // this 指向对象
    //     console.log(this.a);
    //   }
    // }

    // var obj2 = {
    //   a: 2,
    //   test: function () {
    //     console.log(this.a);  // 指向当前方法的上层对象，不会指向其他对象
    //   }
    // }
    // obj.test();
    // obj2.test();


    // function test(a) {
    //   this.a = a;  // window.a = a
    //   console.log(this.a);
    //   // 没有返回值 默认 return undefined
    // }
    // console.log(test(1).a); // 报错

    // function Test(a) {  // 构造函数
    //   this.a = a;
    //   console.log(this.a); // this 指向对象   实例化时
    //   console.log(window.a); // 报错
    // }

    // var test = new Test(1);  // 实例化的结果就是对象
    // console.log(test.a);

    // function Test(a) {
    //   this.a = a;
    // }

    // Test.prototype.say = function() {
    //   console.log(this); // 正常指向实例化对象
    //   console.log(this.a);
    // }

    // var test = new Test(1);
    // test.say();


    // var oBtn = document.getElementById('btn');
    // oBtn.onclick = function () {
    //   console.log(this) // 指向元素本身
    //   this.innerText = '加载中'
    //   this.disabled = true

    //   setTimeout(function () {  // setTimeout 指向 window
    //     console.log(this)
    //     this.innerText = '点击'
    //     this.disabled = false
    //   }.bind(this), // 绑定 this
    //   2000)
    // }

    // function fun () {
    //   // this -> window
    // }

    // call/apply   立即执行
    // - call(context, 1, 2, 3)
    // - applay(context, [1, 2, 3])
    // bind   返回一个新的函数，this 指向填入的第一个参数   不会立即执行
    // -bind(context, 1, 2, 3)

    // var initMoudle = (function () {
    //   return {
    //     a: 1,
    //     b: 2,
    //     plus: function (a, b) {
    //       return this.a + this.b
    //     },
    //     plus2: function (a, b) {
    //       return a +b
    //     }
    //   }
    // })();

    // console.log(initMoudle.plus())
    // console.log(initMoudle.plus2(3, 4))

    // ; (function () {
    //   function Test(a, b) {
    //     this.oBtn = document.getElementById('btn')
    //     this.a = a;
    //     this.b = b;
    //   }

    //   Test.prototype = {
    //     init: function () {
    //       this.bindEvent();
    //     },
    //     bindEvent: function () {
    //       var _self = this;
    //       // this.oBtn.addEventListener('click', this.plus.bind(this), false)
    //       this.oBtn.addEventListener('click', function () {
    //         _self.plus()
    //       }, false)
    //     },
    //     plus: function () {

    //       console.log(this.a + this.b)
    //     }
    //   }

    //   window.Test = Test;

    // })();

    // var test = new Test(1, 13).init()


    // call apply 问题
    function Test1(a, b) {
      console.log(this) // 指向 Test2
      this.a = a;
      this.b = b;

      console.log(this.a, this.b);
    }

    function Test2(a, b, c, d) {
      this.a = a;
      this.b = b;
      // Test1(a, b) // 指向window
      // Test1.call(this, this.a, this.b);
      // Test1.apply(this, [this.a, this.b]);

      this.c = c;
      this.d = d;
      console.log(this.a, this.b, this.c, this.d)
    }

    var test2 = new Test2(1, 2, 3, 4)
  </script>
</body>

</html>